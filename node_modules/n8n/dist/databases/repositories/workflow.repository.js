"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowRepository = void 0;
const config_1 = require("@n8n/config");
const di_1 = require("@n8n/di");
const typeorm_1 = require("@n8n/typeorm");
const utils_1 = require("../../utils");
const tag_entity_1 = require("../entities/tag-entity");
const webhook_entity_1 = require("../entities/webhook-entity");
const workflow_entity_1 = require("../entities/workflow-entity");
const workflow_tag_mapping_1 = require("../entities/workflow-tag-mapping");
let WorkflowRepository = class WorkflowRepository extends typeorm_1.Repository {
    constructor(dataSource, globalConfig) {
        super(workflow_entity_1.WorkflowEntity, dataSource.manager);
        this.globalConfig = globalConfig;
    }
    async get(where, options) {
        return await this.findOne({
            where,
            relations: options?.relations,
        });
    }
    async getAllActiveIds() {
        const result = await this.find({
            select: { id: true },
            where: { active: true },
            relations: { shared: { project: { projectRelations: true } } },
        });
        return result.map(({ id }) => id);
    }
    async getActiveIds({ maxResults } = {}) {
        const activeWorkflows = await this.find({
            select: ['id'],
            where: { active: true },
            ...(maxResults ? { take: maxResults, order: { createdAt: 'ASC' } } : {}),
        });
        return activeWorkflows.map((workflow) => workflow.id);
    }
    async findById(workflowId) {
        return await this.findOne({
            where: { id: workflowId },
            relations: { shared: { project: { projectRelations: true } } },
        });
    }
    async findByIds(workflowIds, { fields } = {}) {
        const options = {
            where: { id: (0, typeorm_1.In)(workflowIds) },
        };
        if (fields?.length)
            options.select = fields;
        return await this.find(options);
    }
    async getActiveTriggerCount() {
        const totalTriggerCount = await this.sum('triggerCount', {
            active: true,
        });
        return totalTriggerCount ?? 0;
    }
    async updateWorkflowTriggerCount(id, triggerCount) {
        const qb = this.createQueryBuilder('workflow');
        const dbType = this.globalConfig.database.type;
        return await qb
            .update()
            .set({
            triggerCount,
            updatedAt: () => {
                if (['mysqldb', 'mariadb'].includes(dbType)) {
                    return 'updatedAt';
                }
                return '"updatedAt"';
            },
        })
            .where('id = :id', { id })
            .execute();
    }
    async getMany(sharedWorkflowIds, options = {}) {
        if (sharedWorkflowIds.length === 0) {
            return { workflows: [], count: 0 };
        }
        const qb = this.createBaseQuery(sharedWorkflowIds);
        this.applyFilters(qb, options.filter);
        this.applySelect(qb, options.select);
        this.applyRelations(qb, options.select);
        this.applySorting(qb, options.sortBy);
        this.applyPagination(qb, options);
        const [workflows, count] = (await qb.getManyAndCount());
        return { workflows, count };
    }
    createBaseQuery(sharedWorkflowIds) {
        return this.createQueryBuilder('workflow').where('workflow.id IN (:...sharedWorkflowIds)', {
            sharedWorkflowIds,
        });
    }
    applyFilters(qb, filter) {
        if (!filter)
            return;
        this.applyNameFilter(qb, filter);
        this.applyActiveFilter(qb, filter);
        this.applyTagsFilter(qb, filter);
        this.applyProjectFilter(qb, filter);
    }
    applyNameFilter(qb, filter) {
        if (typeof filter?.name === 'string' && filter.name !== '') {
            qb.andWhere('LOWER(workflow.name) LIKE :name', {
                name: `%${filter.name.toLowerCase()}%`,
            });
        }
    }
    applyActiveFilter(qb, filter) {
        if (typeof filter?.active === 'boolean') {
            qb.andWhere('workflow.active = :active', { active: filter.active });
        }
    }
    applyTagsFilter(qb, filter) {
        if ((0, utils_1.isStringArray)(filter?.tags) && filter.tags.length > 0) {
            const subQuery = qb
                .subQuery()
                .select('wt.workflowId')
                .from(workflow_tag_mapping_1.WorkflowTagMapping, 'wt')
                .innerJoin(tag_entity_1.TagEntity, 'filter_tags', 'filter_tags.id = wt.tagId')
                .where('filter_tags.name IN (:...tagNames)', { tagNames: filter.tags })
                .groupBy('wt.workflowId')
                .having('COUNT(DISTINCT filter_tags.name) = :tagCount', { tagCount: filter.tags.length });
            qb.andWhere(`workflow.id IN (${subQuery.getQuery()})`).setParameters({
                tagNames: filter.tags,
                tagCount: filter.tags.length,
            });
        }
    }
    applyProjectFilter(qb, filter) {
        if (typeof filter?.projectId === 'string' && filter.projectId !== '') {
            qb.innerJoin('workflow.shared', 'shared').andWhere('shared.projectId = :projectId', {
                projectId: filter.projectId,
            });
        }
    }
    applyOwnedByRelation(qb) {
        if (!qb.expressionMap.aliases.find((alias) => alias.name === 'shared')) {
            qb.leftJoin('workflow.shared', 'shared');
        }
        qb.addSelect([
            'shared.role',
            'shared.createdAt',
            'shared.updatedAt',
            'shared.workflowId',
            'shared.projectId',
        ])
            .leftJoin('shared.project', 'project')
            .addSelect([
            'project.id',
            'project.name',
            'project.type',
            'project.icon',
            'project.createdAt',
            'project.updatedAt',
        ]);
    }
    applySelect(qb, select) {
        qb.select(['workflow.id']);
        if (!select) {
            qb.addSelect([
                'workflow.name',
                'workflow.active',
                'workflow.createdAt',
                'workflow.updatedAt',
                'workflow.versionId',
            ]);
            return;
        }
        const regularFields = Object.entries(select).filter(([field]) => !['ownedBy', 'tags'].includes(field));
        regularFields.forEach(([field, include]) => {
            if (include) {
                qb.addSelect(`workflow.${field}`);
            }
        });
    }
    applyRelations(qb, select) {
        const areTagsEnabled = !this.globalConfig.tags.disabled;
        const isDefaultSelect = select === undefined;
        const areTagsRequested = isDefaultSelect || select?.tags;
        const isOwnedByIncluded = isDefaultSelect || select?.ownedBy;
        if (areTagsEnabled && areTagsRequested) {
            this.applyTagsRelation(qb);
        }
        if (isOwnedByIncluded) {
            this.applyOwnedByRelation(qb);
        }
    }
    applyTagsRelation(qb) {
        qb.leftJoin('workflow.tags', 'tags')
            .addSelect(['tags.id', 'tags.name'])
            .addOrderBy('tags.createdAt', 'ASC');
    }
    applySorting(qb, sortBy) {
        if (!sortBy) {
            this.applyDefaultSorting(qb);
            return;
        }
        const [column, direction] = this.parseSortingParams(sortBy);
        this.applySortingByColumn(qb, column, direction);
    }
    parseSortingParams(sortBy) {
        const [column, order] = sortBy.split(':');
        return [column, order.toUpperCase()];
    }
    applyDefaultSorting(qb) {
        qb.orderBy('workflow.updatedAt', 'ASC');
    }
    applySortingByColumn(qb, column, direction) {
        if (column === 'name') {
            qb.addSelect('LOWER(workflow.name)', 'workflow_name_lower').orderBy('workflow_name_lower', direction);
            return;
        }
        qb.orderBy(`workflow.${column}`, direction);
    }
    applyPagination(qb, options) {
        if (options?.take) {
            qb.skip(options.skip ?? 0).take(options.take);
        }
    }
    async findStartingWith(workflowName) {
        return await this.find({
            select: ['name'],
            where: { name: (0, typeorm_1.Like)(`${workflowName}%`) },
        });
    }
    async findIn(workflowIds) {
        return await this.find({
            select: ['id', 'name'],
            where: { id: (0, typeorm_1.In)(workflowIds) },
        });
    }
    async findWebhookBasedActiveWorkflows() {
        return await this.createQueryBuilder('workflow')
            .select('DISTINCT workflow.id, workflow.name')
            .innerJoin(webhook_entity_1.WebhookEntity, 'webhook_entity', 'workflow.id = webhook_entity.workflowId')
            .execute();
    }
    async updateActiveState(workflowId, newState) {
        return await this.update({ id: workflowId }, { active: newState });
    }
    async deactivateAll() {
        return await this.update({ active: true }, { active: false });
    }
    async activateAll() {
        return await this.update({ active: false }, { active: true });
    }
    async findByActiveState(activeState) {
        return await this.findBy({ active: activeState });
    }
};
exports.WorkflowRepository = WorkflowRepository;
exports.WorkflowRepository = WorkflowRepository = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [typeorm_1.DataSource,
        config_1.GlobalConfig])
], WorkflowRepository);
//# sourceMappingURL=workflow.repository.js.map