import { gh as baseSlice, gi as toString, bo as useNodeTypesStore, q as computed, l as unref, eM as isSubNodeType, Z as useRootStore, T as useWorkflowsStore, a as useToast, gj as PIN_DATA_NODE_TYPES_DENYLIST, bg as getNodeOutputs, bh as NodeConnectionType, gk as jsonStringify, gl as toMegaBytes, gm as stringSizeInBytes, ch as jsonParse, g as useI18n, aj as useTelemetry, aT as useExternalHooks, eN as useDataSchema, gn as MAX_PINNED_DATA_SIZE, go as MAX_WORKFLOW_SIZE, gp as MAX_EXPECTED_REQUEST_SIZE, bp as useNodeHelpers, a4 as useWorkflowHelpers, p as useSettingsStore, K as useUIStore, at as useExecutionsStore, b7 as CHAT_TRIGGER_NODE_TYPE, bj as get, gq as SINGLE_WEBHOOK_TRIGGERS, gr as displayForm, cL as isEmpty, dR as generateNodesGraph } from "./index-DCrfHAqy.js";
import { u as usePushConnectionStore } from "./pushConnection.store-BfRLeHNn.js";
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice(array, start, end);
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}
function useNodeType(options = {}) {
  const nodeTypesStore = useNodeTypesStore();
  const nodeType = computed(() => {
    if (options.nodeType) {
      return unref(options.nodeType);
    }
    const activeNode = unref(options.node);
    if (activeNode) {
      return nodeTypesStore.getNodeType(activeNode.type, activeNode.typeVersion);
    }
    return null;
  });
  const isSubNodeType$1 = computed(() => isSubNodeType(nodeType.value));
  const isMultipleOutputsNodeType = computed(() => {
    const outputs = nodeType.value?.outputs;
    if (typeof outputs === "string") return false;
    return (outputs ?? []).length > 1;
  });
  return {
    nodeType,
    isSubNodeType: isSubNodeType$1,
    isMultipleOutputsNodeType
  };
}
function usePinnedData(node, options = {}) {
  const rootStore = useRootStore();
  const workflowsStore = useWorkflowsStore();
  const toast = useToast();
  const i18n = useI18n();
  const telemetry = useTelemetry();
  const externalHooks = useExternalHooks();
  const { getInputDataWithPinned } = useDataSchema();
  const { isSubNodeType: isSubNodeType2, isMultipleOutputsNodeType } = useNodeType({
    node
  });
  const data = computed(() => {
    const targetNode = unref(node);
    return targetNode ? workflowsStore.pinDataByNodeName(targetNode.name) : void 0;
  });
  const hasData = computed(() => {
    const targetNode = unref(node);
    return !!targetNode && typeof data.value !== "undefined";
  });
  const isValidNodeType = computed(() => {
    const targetNode = unref(node);
    return !!targetNode && !isSubNodeType2.value && !isMultipleOutputsNodeType.value && !PIN_DATA_NODE_TYPES_DENYLIST.includes(targetNode.type);
  });
  function canPinNode(checkDataEmpty = false, outputIndex) {
    const targetNode = unref(node);
    if (targetNode === null || PIN_DATA_NODE_TYPES_DENYLIST.includes(targetNode.type)) return false;
    const nodeType = useNodeTypesStore().getNodeType(targetNode.type, targetNode.typeVersion);
    const dataToPin = getInputDataWithPinned(targetNode);
    if (!nodeType || checkDataEmpty && dataToPin.length === 0) return false;
    const workflow = workflowsStore.getCurrentWorkflow();
    const outputs = getNodeOutputs(workflow, targetNode, nodeType).map(
      (output) => typeof output === "string" ? { type: output } : output
    );
    const mainOutputs = outputs.filter(
      (output) => output.type === NodeConnectionType.Main && output.category !== "error"
    );
    let indexAcceptable = true;
    if (outputIndex !== void 0) {
      const output = outputs[outputIndex];
      if (outputs[outputIndex] === void 0) return false;
      indexAcceptable = output.type === NodeConnectionType.Main && output.category !== "error";
    }
    return mainOutputs.length === 1 && indexAcceptable;
  }
  function isValidJSON(data2) {
    try {
      JSON.parse(data2);
      return true;
    } catch (error) {
      const title = i18n.baseText("runData.editOutputInvalid");
      const toRemove = new RegExp(/JSON\.parse:|of the JSON data/, "g");
      const message = error.message.replace(toRemove, "").trim();
      const positionMatchRegEx = /at position (\d+)/;
      const positionMatch = error.message.match(positionMatchRegEx);
      error.message = message.charAt(0).toUpperCase() + message.slice(1);
      error.message = error.message.replace(
        "Unexpected token ' in JSON",
        i18n.baseText("runData.editOutputInvalid.singleQuote")
      );
      if (positionMatch) {
        const position = parseInt(positionMatch[1], 10);
        const lineBreaksUpToPosition = (data2.slice(0, position).match(/\n/g) || []).length;
        error.message = error.message.replace(
          positionMatchRegEx,
          i18n.baseText("runData.editOutputInvalid.atPosition", {
            interpolate: {
              position: `${position}`
            }
          })
        );
        error.message = `${i18n.baseText("runData.editOutputInvalid.onLine", {
          interpolate: {
            line: `${lineBreaksUpToPosition + 1}`
          }
        })} ${error.message}`;
      }
      toast.showError(error, title);
      return false;
    }
  }
  function getMaxPinnedDataSize() {
    return window.maxPinnedDataSize ?? MAX_PINNED_DATA_SIZE;
  }
  function isValidSize(data2) {
    const targetNode = unref(node);
    if (!targetNode) {
      return false;
    }
    if (typeof data2 === "object") data2 = JSON.stringify(data2);
    const { pinData: currentPinData, ...workflow } = workflowsStore.getCurrentWorkflow();
    const workflowJson = jsonStringify(workflow, { replaceCircularRefs: true });
    const newPinData = { ...currentPinData, [targetNode.name]: data2 };
    const newPinDataSize = workflowsStore.getPinDataSize(newPinData);
    if (newPinDataSize > getMaxPinnedDataSize()) {
      toast.showError(
        new Error(
          i18n.baseText("ndv.pinData.error.tooLarge.description", {
            interpolate: {
              size: toMegaBytes(newPinDataSize),
              limit: toMegaBytes(getMaxPinnedDataSize())
            }
          })
        ),
        i18n.baseText("ndv.pinData.error.tooLarge.title")
      );
      return false;
    }
    const workflowSize = stringSizeInBytes(workflowJson) + newPinDataSize;
    const limit = MAX_WORKFLOW_SIZE - MAX_EXPECTED_REQUEST_SIZE;
    if (workflowSize > limit) {
      toast.showError(
        new Error(
          i18n.baseText("ndv.pinData.error.tooLargeWorkflow.description", {
            interpolate: { size: toMegaBytes(workflowSize), limit: toMegaBytes(limit) }
          })
        ),
        i18n.baseText("ndv.pinData.error.tooLargeWorkflow.title")
      );
      return false;
    }
    return true;
  }
  function onSetDataSuccess({ source }) {
    const targetNode = unref(node);
    const displayMode = unref(options.displayMode);
    const runIndex = unref(options.runIndex);
    const telemetryPayload = {
      pinning_source: source,
      node_type: targetNode?.type,
      push_ref: rootStore.pushRef,
      data_size: stringSizeInBytes(data.value),
      view: displayMode,
      run_index: runIndex
    };
    void externalHooks.run("runData.onDataPinningSuccess", telemetryPayload);
    telemetry.track("Ndv data pinning success", telemetryPayload);
  }
  function onSetDataError({
    errorType,
    source
  }) {
    const targetNode = unref(node);
    const displayMode = unref(options.displayMode);
    const runIndex = unref(options.runIndex);
    telemetry.track("Ndv data pinning failure", {
      pinning_source: source,
      node_type: targetNode?.type,
      push_ref: rootStore.pushRef,
      data_size: stringSizeInBytes(data.value),
      view: displayMode,
      run_index: runIndex,
      error_type: errorType
    });
  }
  function setData(data2, source) {
    const targetNode = unref(node);
    if (!targetNode) {
      return;
    }
    if (typeof data2 === "string") {
      if (!isValidJSON(data2)) {
        onSetDataError({ errorType: "invalid-json", source });
        throw new Error("Invalid JSON");
      }
      data2 = jsonParse(data2);
    }
    if (!isValidSize(data2)) {
      onSetDataError({ errorType: "data-too-large", source });
      throw new Error("Data too large");
    }
    workflowsStore.pinData({ node: targetNode, data: data2 });
    onSetDataSuccess({ source });
  }
  function onUnsetData({ source }) {
    const targetNode = unref(node);
    const runIndex = unref(options.runIndex);
    telemetry.track("User unpinned ndv data", {
      node_type: targetNode?.type,
      push_ref: rootStore.pushRef,
      run_index: runIndex,
      source,
      data_size: stringSizeInBytes(data.value)
    });
  }
  function unsetData(source) {
    const targetNode = unref(node);
    if (!targetNode) {
      return;
    }
    onUnsetData({ source });
    workflowsStore.unpinData({ node: targetNode });
  }
  return {
    data,
    hasData,
    isValidNodeType,
    canPinNode,
    setData,
    onSetDataSuccess,
    onSetDataError,
    unsetData,
    onUnsetData,
    isValidJSON,
    isValidSize
  };
}
const getDirtyNodeNames = (runData, getParametersLastUpdate) => {
  const dirtyNodeNames = Object.entries(runData).reduce((acc, [nodeName, tasks]) => {
    if (!tasks.length) return acc;
    const updatedAt = getParametersLastUpdate(nodeName) ?? 0;
    if (updatedAt > tasks[0].startTime) {
      acc.push(nodeName);
    }
    return acc;
  }, []);
  return dirtyNodeNames.length ? dirtyNodeNames : void 0;
};
function useRunWorkflow(useRunWorkflowOpts) {
  const nodeHelpers = useNodeHelpers();
  const workflowHelpers = useWorkflowHelpers({ router: useRunWorkflowOpts.router });
  const i18n = useI18n();
  const toast = useToast();
  const telemetry = useTelemetry();
  const externalHooks = useExternalHooks();
  const settingsStore = useSettingsStore();
  const rootStore = useRootStore();
  const pushConnectionStore = usePushConnectionStore();
  const uiStore = useUIStore();
  const workflowsStore = useWorkflowsStore();
  const executionsStore = useExecutionsStore();
  async function runWorkflowApi(runData) {
    if (!pushConnectionStore.isConnected) {
      throw new Error(i18n.baseText("workflowRun.noActiveConnectionToTheServer"));
    }
    workflowsStore.subWorkflowExecutionError = null;
    uiStore.addActiveAction("workflowRunning");
    let response;
    try {
      response = await workflowsStore.runWorkflow(runData);
    } catch (error) {
      uiStore.removeActiveAction("workflowRunning");
      throw error;
    }
    if (response.executionId !== void 0) {
      workflowsStore.activeExecutionId = response.executionId;
    }
    if (response.waitingForWebhook === true && useWorkflowsStore().nodesIssuesExist) {
      uiStore.removeActiveAction("workflowRunning");
      throw new Error(i18n.baseText("workflowRun.showError.resolveOutstandingIssues"));
    }
    if (response.waitingForWebhook === true) {
      workflowsStore.executionWaitingForWebhook = true;
    }
    return response;
  }
  async function runWorkflow(options) {
    const workflow = workflowHelpers.getCurrentWorkflow();
    if (uiStore.isActionActive["workflowRunning"]) {
      return;
    }
    toast.clearAllStickyNotifications();
    try {
      let directParentNodes = [];
      if (options.destinationNode !== void 0) {
        directParentNodes = workflow.getParentNodes(
          options.destinationNode,
          NodeConnectionType.Main,
          -1
        );
      }
      const runData = workflowsStore.getWorkflowRunData;
      if (workflowsStore.isNewWorkflow) {
        await workflowHelpers.saveCurrentWorkflow();
      }
      const workflowData = await workflowHelpers.getWorkflowDataToSave();
      const consolidatedData = consolidateRunDataAndStartNodes(
        directParentNodes,
        runData,
        workflowData.pinData,
        workflow
      );
      const { startNodeNames } = consolidatedData;
      const destinationNodeType = options.destinationNode ? workflowsStore.getNodeByName(options.destinationNode)?.type : "";
      let { runData: newRunData } = consolidatedData;
      let executedNode;
      let triggerToStartFrom;
      if (startNodeNames.length === 0 && "destinationNode" in options && options.destinationNode !== void 0) {
        executedNode = options.destinationNode;
        startNodeNames.push(options.destinationNode);
      } else if (options.triggerNode && options.nodeData) {
        startNodeNames.push(
          ...workflow.getChildNodes(options.triggerNode, NodeConnectionType.Main, 1)
        );
        newRunData = { [options.triggerNode]: [options.nodeData] };
        executedNode = options.triggerNode;
      }
      if (options.triggerNode) {
        triggerToStartFrom = {
          name: options.triggerNode,
          data: options.nodeData
        };
      }
      if (options.destinationNode && (workflowsStore.checkIfNodeHasChatParent(options.destinationNode) || destinationNodeType === CHAT_TRIGGER_NODE_TYPE) && options.source !== "RunData.ManualChatMessage") {
        const startNode = workflow.getStartNode(options.destinationNode);
        if (startNode && startNode.type === CHAT_TRIGGER_NODE_TYPE) {
          const chatHasInputData = nodeHelpers.getNodeInputData(startNode, 0, 0, "input")?.length > 0;
          const chatHasPinData = !!workflowData.pinData?.[startNode.name];
          if (!chatHasInputData && !chatHasPinData) {
            workflowsStore.chatPartialExecutionDestinationNode = options.destinationNode;
            workflowsStore.setPanelOpen("chat", true);
            return;
          }
        }
      }
      const triggers = workflowData.nodes.filter(
        (node) => node.type.toLowerCase().includes("trigger") && !node.disabled
      );
      if (!options.destinationNode && options.source !== "RunData.ManualChatMessage" && workflowData.nodes.some((node) => node.type === CHAT_TRIGGER_NODE_TYPE)) {
        const otherTriggers = triggers.filter((node) => node.type !== CHAT_TRIGGER_NODE_TYPE);
        if (otherTriggers.length) {
          const chatTriggerNode = workflowData.nodes.find(
            (node) => node.type === CHAT_TRIGGER_NODE_TYPE
          );
          if (chatTriggerNode) {
            chatTriggerNode.disabled = true;
          }
        }
      }
      const startNodes = startNodeNames.map((name) => {
        let sourceData = get(runData, [name, 0, "source", 0], null);
        if (sourceData === null) {
          const parentNodes = workflow.getParentNodes(name, NodeConnectionType.Main, 1);
          const executeData = workflowHelpers.executeData(
            parentNodes,
            name,
            NodeConnectionType.Main,
            0
          );
          sourceData = get(executeData, ["source", NodeConnectionType.Main, 0], null);
        }
        return {
          name,
          sourceData
        };
      });
      const singleWebhookTrigger = triggers.find(
        (node) => SINGLE_WEBHOOK_TRIGGERS.includes(node.type)
      );
      if (singleWebhookTrigger && workflowsStore.isWorkflowActive && !workflowData.pinData?.[singleWebhookTrigger.name]) {
        toast.showMessage({
          title: i18n.baseText("workflowRun.showError.deactivate"),
          message: i18n.baseText("workflowRun.showError.productionActive", {
            interpolate: { nodeName: singleWebhookTrigger.name }
          }),
          type: "error"
        });
        return void 0;
      }
      const isPartialExecution = options.destinationNode !== void 0;
      const settingsStore2 = useSettingsStore();
      const version = settingsStore2.partialExecutionVersion;
      const startRunData = {
        workflowData,
        // With the new partial execution version the backend decides what run
        // data to use and what to ignore.
        runData: !isPartialExecution ? (
          // if it's a full execution we don't want to send any run data
          void 0
        ) : version === 2 ? (
          // With the new partial execution version the backend decides
          //what run data to use and what to ignore.
          runData ?? void 0
        ) : (
          // for v0 we send the run data the FE constructed
          newRunData
        ),
        startNodes,
        triggerToStartFrom
      };
      if ("destinationNode" in options) {
        startRunData.destinationNode = options.destinationNode;
      }
      if (startRunData.runData) {
        startRunData.dirtyNodeNames = getDirtyNodeNames(
          startRunData.runData,
          workflowsStore.getParametersLastUpdate
        );
      }
      const executionData = {
        id: "__IN_PROGRESS__",
        finished: false,
        mode: "manual",
        status: "running",
        createdAt: /* @__PURE__ */ new Date(),
        startedAt: /* @__PURE__ */ new Date(),
        stoppedAt: void 0,
        workflowId: workflow.id,
        executedNode,
        triggerNode: triggerToStartFrom?.name,
        data: {
          resultData: {
            runData: startRunData.runData ?? {},
            pinData: workflowData.pinData,
            workflowData
          }
        },
        workflowData: {
          id: workflowsStore.workflowId,
          name: workflowData.name,
          active: workflowData.active,
          createdAt: 0,
          updatedAt: 0,
          ...workflowData
        }
      };
      workflowsStore.setWorkflowExecutionData(executionData);
      nodeHelpers.updateNodesExecutionIssues();
      workflowHelpers.setDocumentTitle(workflow.name, "EXECUTING");
      const runWorkflowApiResponse = await runWorkflowApi(startRunData);
      const pinData = workflowData.pinData ?? {};
      const getTestUrl = /* @__PURE__ */ (() => {
        return (node) => {
          const path = node.parameters.path || node.parameters.options?.path || node.webhookId;
          return `${rootStore.formTestUrl}/${path}`;
        };
      })();
      try {
        displayForm({
          nodes: workflowData.nodes,
          runData: workflowsStore.getWorkflowExecution?.data?.resultData?.runData,
          destinationNode: options.destinationNode,
          pinData,
          directParentNodes,
          source: options.source,
          getTestUrl
        });
      } catch (error) {
      }
      await externalHooks.run("workflowRun.runWorkflow", {
        nodeName: options.destinationNode,
        source: options.source
      });
      return runWorkflowApiResponse;
    } catch (error) {
      workflowHelpers.setDocumentTitle(workflow.name, "ERROR");
      toast.showError(error, i18n.baseText("workflowRun.showError.title"));
      return void 0;
    }
  }
  function consolidateRunDataAndStartNodes(directParentNodes, runData, pinData, workflow) {
    const startNodeNames = /* @__PURE__ */ new Set();
    let newRunData;
    if (runData !== null && Object.keys(runData).length !== 0) {
      newRunData = {};
      for (const directParentNode of directParentNodes) {
        const parentNodes = workflow.getParentNodes(directParentNode, NodeConnectionType.Main);
        if (workflow.nodes[directParentNode].disabled) continue;
        parentNodes.push(directParentNode);
        for (const parentNode of parentNodes) {
          if (!runData[parentNode]?.length && !pinData?.[parentNode]?.length || runData[parentNode]?.[0]?.error !== void 0) {
            startNodeNames.add(parentNode);
            break;
          }
          if (runData[parentNode] && !runData[parentNode]?.[0]?.error) {
            newRunData[parentNode] = runData[parentNode]?.slice(0, 1);
          }
        }
      }
      if (isEmpty(newRunData)) {
        newRunData = void 0;
      }
    }
    return { runData: newRunData, startNodeNames: [...startNodeNames] };
  }
  async function stopCurrentExecution() {
    const executionId = workflowsStore.activeExecutionId;
    if (executionId === null) {
      return;
    }
    try {
      await executionsStore.stopCurrentExecution(executionId);
    } catch (error) {
      const execution = await workflowsStore.getExecution(executionId);
      if (execution === void 0) {
        toast.showMessage({
          title: i18n.baseText("nodeView.showMessage.stopExecutionCatch.unsaved.title"),
          message: i18n.baseText("nodeView.showMessage.stopExecutionCatch.unsaved.message"),
          type: "success"
        });
      } else if (execution?.finished) {
        const executedData = {
          data: execution.data,
          finished: execution.finished,
          mode: execution.mode,
          startedAt: execution.startedAt,
          stoppedAt: execution.stoppedAt
        };
        workflowsStore.setWorkflowExecutionData(executedData);
        toast.showMessage({
          title: i18n.baseText("nodeView.showMessage.stopExecutionCatch.title"),
          message: i18n.baseText("nodeView.showMessage.stopExecutionCatch.message"),
          type: "success"
        });
      } else {
        toast.showError(error, i18n.baseText("nodeView.showError.stopExecution.title"));
      }
    } finally {
      workflowsStore.markExecutionAsStopped();
    }
  }
  async function stopWaitingForWebhook() {
    try {
      await workflowsStore.removeTestWebhook(workflowsStore.workflowId);
    } catch (error) {
      toast.showError(error, i18n.baseText("nodeView.showError.stopWaitingForWebhook.title"));
      return;
    }
  }
  async function runEntireWorkflow(source, triggerNode) {
    const workflow = workflowHelpers.getCurrentWorkflow();
    void workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
      const telemetryPayload = {
        workflow_id: workflow.id,
        node_graph_string: JSON.stringify(
          generateNodesGraph(
            workflowData,
            workflowHelpers.getNodeTypes(),
            { isCloudDeployment: settingsStore.isCloudDeployment }
          ).nodeGraph
        ),
        button_type: source
      };
      telemetry.track("User clicked execute workflow button", telemetryPayload);
      void externalHooks.run("nodeView.onRunWorkflow", telemetryPayload);
    });
    void runWorkflow({ triggerNode });
  }
  return {
    consolidateRunDataAndStartNodes,
    runEntireWorkflow,
    runWorkflow,
    runWorkflowApi,
    stopCurrentExecution,
    stopWaitingForWebhook
  };
}
export {
  useRunWorkflow as a,
  useNodeType as b,
  capitalize as c,
  upperFirst as d,
  usePinnedData as u
};
